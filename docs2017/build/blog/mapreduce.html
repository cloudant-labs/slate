<html lang="en">
<head>
  <title>IBM&reg; Cloudant&reg; NoSQL DB for Bluemix&reg;</title>
  <meta charset="utf-8"></meta>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
</head>

<body>
  <h1 id="mapreduce">MapReduce</h1>
  <p class="shortdesc"><em>(This is a republication of a Blog article by Mike Miller:
&quot;MapReduce: From the basics to the actually useful (in under 30 minutes)&quot;,
originally published January 13, 2011.)</em></p>
  <h2 id="from-the-basics-to-the-actually-useful-in-under-30-minutes-">From the basics to the actually useful (in under 30 minutes)</h2>
  <p>Recently, Tim Anglade culminated his NOSQL World Tour with the release of
    <a href="http://nosqltapes.com/" target="_blank">the NOSQL Tapes <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>, a collection of live interviews collected globally. Not only do I find that site aesthetically
    pleasing (courtesy of our own
    <a href="http://twitter.com/steadicat" target="_blank">Steadicat <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>), but there is a tremendous amount of solid content, from technical discussions to opinions
    and conjectures from many of the young leaders in the field. I was fortunate to get a bit of Tim&#39;s time when he stopped in Seattle and we recorded a
    <a href="http://nosqltap.es/8" target="_blank">longish video <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a> on MapReduce in my lab at UW. While I love the old school feel of a chalk-talk, I must admit
    I&#39;m pretty embarrassed at how rambling and fragmented my explanations are, not to mention my shoddy use of available board space. Therefore the Physics Professor in me feels obligated to try again, albeit offline this time.</p>
  <h2 id="brief-nosql-taxonomy">Brief NOSQL Taxonomy</h2>
  <p>To set the MapReduce stage, I&#39;m going to offer a very naive taxonomy of NoSQL data stores (apologies to the experts). I have yet to meet a database that isn&#39;t a key/value store, so let&#39;s focus on some higher level distinction. In particular,
    let&#39;s focus on the difference between <em>big tables</em> (BigTable, HBase, Cassandra, etc.) and <em>document stores</em> (CouchDB, MongoDB). All of these solutions are finding solid acceptance in the wild, so what - if any - difference is there?
    My one-word answer is <em>flexibility</em>. Huh, isn&#39;t all NoSQL flexible? Well... yes and no. In my eyes, BigTable and its derivatives excel at one thing in particular: structuring your data for the efficient I/O access that is necessary to get
    blazing read speeds for large data sets. Somewhat orthogonal, document stores, especially CouchDB, prioritize flexibility. In particular, there is no requirement to define columns, column families, or super columns up front. You simply encapsulate
    your data as documents and push them into the store. How then, you may ask, can you get efficient queries? MongoDB treats the problem with blazingly fast in-memory table scans and document introspection for index builds, whereas CouchDB takes a different
    approach with something called incremental MapReduce. I&#39;m going to briefly explain the latter and then show you how it works in action.</p>
  <h2 id="mapreduce-primer">MapReduce Primer</h2>
  <p>MapReduce is an old design pattern that was recently made famous by Google. There are many different implementations, and I won&#39;t even try to address them all. It suffices to say that MapReduce is all about giving programmers an efficient way to
    consume data without needing to know how or where it is actually stored. Further, MapReduce excels at traversing datasets that live on more than one machine. It is simple, a bit restrictive, but extremely powerful. I&#39;m going to show you how it
    works in CouchDB (well, actually in BigCouch hosted on Cloudant.com).</p>
  <p>Broadly speaking, CouchDB (and Cloudant&#39;s BigCouch) use MapReduce as a tool to let you introspect your data and build persistent &#39;views&#39; (indices) for fast query responses. And, oh yeah, it does it incrementally. Let&#39;s examine the pieces
    in detail:</p>
  <ul>
    <li><strong>View builds.</strong> The process of scanning over your data to create indices that make queries fast. This step also often performs data normalization.</li>
    <li><strong>MapReduce.</strong> The framework by which user code gets executed for index builds.</li>
    <li><strong>View queries.</strong> How you get the information out of your indices.</li>
    <li><strong>Incremental.</strong> When new documents are added or existing documents are modified/removed, you don&#39;t need to rescan your entire dataset. Instead the view engine only rescans the new/modified documents, and deletes the contributions
      from the deleted/modified documents. It&#39;s a complex implementation, but one that really separates the Couch MapReduce model from, e.g., Hadoop&#39;s or Riak&#39;s implementations.</li>
  </ul>
  <p>For full details on Cloudant&#39;s implementation of MapReduce, take a look at <a href="dynamo.html">Dynamo and CouchDB Clusters</a> and
    <a href="http://oreillynet.com/pub/e/1760" target="_blank">Adam&#39;s O&#39;Reilly Webcast <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>. So what do you actually have to do? Well, you simply need to
    write one or two functions. The &#39;map&#39; function is required, and the &#39;reduce&#39; is optional. For simple sorting problems (e.g. building a SEO reverse index) map alone suffices. For data aggregation, reduce comes into the picture. CouchDB
    allows you to write these functions in any language you choose, although JavaScript is the most common. Let&#39;s put some meat on the bones with examples. Below I&#39;m going to show you how to do three of the most common things people do with CouchDB&#39;s
    MapReduce:</p>
  <ol>
    <li>Sort documents based on arbitrary information.</li>
    <li>Calculate aggregate statistics.</li>
    <li>Perform a time-series analysis.</li>
  </ol>
  <h2 id="our-example-problem">Our Example Problem</h2>
  <p>We are going to load and analyze FAA plane crash data from
    <a href="http://data.gov/" target="_blank">data.gov <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a> using Cloudant. If you want to follow along at home, you have two choices.</p>
  <ol>
    <li>Use CouchDB replication to copy my db into yours via:<pre class="pre"><code class="lang-sh hljs">curl <span class="hljs-string">'http://&lt;usr&gt;:&lt;pwd&gt;@&lt;usr&gt;.cloudant.com/_replicate'</span> -Hcontent-type:application/json <span class="hljs-_">-d</span> <span class="hljs-string">'{"source":"http://mlmiller.cloudant.com/planes","target":"http://&lt;usr&gt;:&lt;pwd&gt;@&lt;usr&gt;.cloudant.com/planes","create_target":true}'</span>
</code></pre>
    </li>
    <li>Repeat from scratch by
      <a href="http://github.com/mlmiller/examples/tree/master/aviation" target="_blank">getting the code <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a> from Github.</li>
  </ol>
  <p>(1) is simpler and <em>doesn&#39;t require any special software installed on your machine</em>. All you need is to have a free account on
    <a href="http://cloudant.com/" target="_blank">Cloudant <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>. (2) is a bit more effort but should work with any CouchDB server. If you go with (1), the best
    way to check the progress is to
    <a href="http://cloudant.com/" target="_blank">login to your account <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>, click on your user dashboard (top right) and then click on the newly created &#39;planes&#39;
    database. If you examine the Stats tab and refresh periodically, you will see the db size increasing, as well as some MapReduce &#39;views&#39; running as the data imports:<br>
    <img src="images/planes-indexing.png" alt="Planes indexing"></p>
  <p>That bar that registers 31.7% is telling you that MapReduce is being used to index your documents in real time without you having to write any code at all. The &#39;2839 of 8952&#39; on the right represents the fraction of freshly added/updated documents
    that is processed in this current pass, and if you click on &#39;show details&#39; you can see the results of the MapReduce processes on each of the cluster nodes that contain any chunk of your data. That&#39;s just how easy it is to get your code
    running, in parallel, in realtime!</p>
  <h2 id="data-import">Data Import</h2>
  <p>I&#39;ve chosen to import the FAA crash data using my favorite tools: Python and Benoit&#39;s
    <a href="http://couchdbkit.org/" target="_blank">Couchdbkit <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a> library. If you use the Python
    <a href="https://code.google.com/p/boto/" target="_blank">Boto <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a> module for AWS, you will feel right at home. In <a href="https://github.com/mlmiller/examples/blob/master/aviation/upload.py"
      target="_blank">upload.py <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>, I use the very handy <code>DictReader</code> class from Python&#39;s <code>csv</code> module to parse the <code>AviationData.txt.gz</code>.
    <code>DictReader</code> slurps a line of a CSV (or similarly structured text file) with column headings and gives you back a dictionary. It&#39;s a one-liner to serialize that Python dictionary and push it into Cloudant. If you want to try this yourself
    the <code>README</code> file has instructions on installing the Couchdbkit module and executing the <code>upload.py</code> script, but it just boils down to:</p>
  <pre class="pre"><code class="lang-sh hljs">python upload.py AviationData.txt.gz <span class="hljs-string">'http://&lt;username&gt;:&lt;password&gt;@&lt;username&gt;.cloudant.com'</span> planes
</code></pre>
  <p>My imported data lives at
    <a href="http://mlmiller.cloudant.com/planes" target="_blank">http://mlmiller.cloudant.com/planes <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>.</p>
  <p>One thing to note: you can see that I don&#39;t take any steps to discover the type of the data on import. Instead, we just throw it all into Cloudant and we can sort it out later using MapReduce (_flexible_). Once the data is fully imported, I can
    login into
    <a href="https://cloudant.com/" target="_blank">cloudant.com <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a> and view the &#39;planes&#39; database in the dashboard:<br>
    <img src="images/planes-stats.png" alt="Planes statistics"></p>
  <p>I&#39;ve also gone into the Permissions tab and granted read access to the data:<br>
    <img src="images/planes-permissions.png" alt="Planes permissions"></p>
  <p>Each document contains quite a bit of data, too much to fit onto a single screen shot, in fact:<br>
    <img src="images/planes-documents.png" alt="Planes documents"></p>
  <p>But the important thing to note is that we have data for nearly 70,000 domestic accidents, spanning the range 1988–2010. If you want to look at a single document from your command line, you can via:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://&lt;usr&gt;:&lt;pwd&gt;@&lt;usr&gt;.cloudant.com/planes/_all_docs?limit=1&amp;include_docs=true'</span>
</code></pre>
  <p>and if you want it pretty printed, my favorite is:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://&lt;usr&gt;:&lt;pwd&gt;@&lt;usr&gt;.cloudant.com/planes/_all_docs?limit=1&amp;include_docs=true'</span> | python -m json.tool
</code></pre>
  <p>Since I&#39;ve granted read permissions on mlmiller/planes, you can execute this yourself via:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://mlmiller.cloudant.com/planes/_all_docs?limit=1&amp;include_docs=true'</span> | python -m json.tool
{
    <span class="hljs-string">"offset"</span>: 0,
    <span class="hljs-string">"rows"</span>: [
        {
            <span class="hljs-string">"doc"</span>: {
                <span class="hljs-string">""</span>: <span class="hljs-string">""</span>,
                <span class="hljs-string">"Accident Number"</span>: <span class="hljs-string">"LAX08CA100"</span>,
                <span class="hljs-string">"Air Carrier"</span>: <span class="hljs-string">""</span>,
                <span class="hljs-string">"Aircraft Category"</span>: <span class="hljs-string">""</span>,
                <span class="hljs-string">"Aircraft Damage"</span>: <span class="hljs-string">"Substantial"</span>,
                <span class="hljs-string">"Airport Code"</span>: <span class="hljs-string">"U42"</span>,
                <span class="hljs-string">"Airport Name"</span>: <span class="hljs-string">"Salt Lake City Muni 2"</span>,
                <span class="hljs-string">"Amateur Built"</span>: <span class="hljs-string">"Yes"</span>,
                <span class="hljs-string">"Broad Phase of Flight"</span>: <span class="hljs-string">""</span>,
                <span class="hljs-string">"Country"</span>: <span class="hljs-string">"United States"</span>,
                <span class="hljs-string">"Engine Type"</span>: <span class="hljs-string">"Reciprocating"</span>,
                <span class="hljs-string">"Event Date"</span>: <span class="hljs-string">"04/12/2008"</span>,
                <span class="hljs-string">"Event Id"</span>: <span class="hljs-string">"20080513X00662"</span>,
                <span class="hljs-string">"FAR Description"</span>: <span class="hljs-string">""</span>,
                <span class="hljs-string">"Injury Severity"</span>: <span class="hljs-string">"Non-Fatal"</span>,
                <span class="hljs-string">"Investigation Type"</span>: <span class="hljs-string">"Accident"</span>,
                <span class="hljs-string">"Latitude"</span>: <span class="hljs-string">"40.619445"</span>,
                <span class="hljs-string">"Location"</span>: <span class="hljs-string">"Salt Lake City, UT"</span>,
                <span class="hljs-string">"Longitude"</span>: <span class="hljs-string">"-111.992777"</span>,
                <span class="hljs-string">"Make"</span>: <span class="hljs-string">"Questair, Inc."</span>,
                <span class="hljs-string">"Model"</span>: <span class="hljs-string">"Venture"</span>,
                <span class="hljs-string">"Number of Engines"</span>: <span class="hljs-string">"1"</span>,
                <span class="hljs-string">"Publication Date"</span>: <span class="hljs-string">"05/28/2008"</span>,
                <span class="hljs-string">"Purpose of Flight"</span>: <span class="hljs-string">"Personal"</span>,
                <span class="hljs-string">"Registration Number"</span>: <span class="hljs-string">"N36V"</span>,
                <span class="hljs-string">"Report Status"</span>: <span class="hljs-string">"Probable Cause"</span>,
                <span class="hljs-string">"Schedule"</span>: <span class="hljs-string">""</span>,
                <span class="hljs-string">"Total Fatal Injuries"</span>: <span class="hljs-string">""</span>,
                <span class="hljs-string">"Total Minor Injuries"</span>: <span class="hljs-string">"2"</span>,
                <span class="hljs-string">"Total Serious Injuries"</span>: <span class="hljs-string">""</span>,
                <span class="hljs-string">"Total Uninjured"</span>: <span class="hljs-string">""</span>,
                <span class="hljs-string">"Weather Condition"</span>: <span class="hljs-string">"VMC"</span>,
                <span class="hljs-string">"_id"</span>: <span class="hljs-string">"0fedbabcd21f15785750457f83000947"</span>,
                <span class="hljs-string">"_rev"</span>: <span class="hljs-string">"1-3e9637bb5214c82fc7b29bb4a75e765b"</span>
            },
            <span class="hljs-string">"id"</span>: <span class="hljs-string">"0fedbabcd21f15785750457f83000947"</span>,
            <span class="hljs-string">"key"</span>: <span class="hljs-string">"0fedbabcd21f15785750457f83000947"</span>,
            <span class="hljs-string">"value"</span>: {
                <span class="hljs-string">"rev"</span>: <span class="hljs-string">"1-3e9637bb5214c82fc7b29bb4a75e765b"</span>
            }
        }
    ],
    <span class="hljs-string">"total_rows"</span>: 68388
}
</code></pre>
  <h2 id="example-1-sort">Example 1: Sort</h2>
  <p>Now that we have the data, let&#39;s get down to business. Key/Value is great, but I want to be able get find all the documents for a given brand of plane, say Cessna. This is really an inverted index, and is in the absolute sweet spot for MapReduce.
    We can accomplish this with a &#39;map-only&#39; view that looks like:</p>
  <pre class="codeblock"><code class="lang-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
    emit(doc.Make, <span class="hljs-literal">null</span>);
}
</code></pre>
  <p>The MapReduce code is actually stored in the database as part of a view in a design document (see the
    <a href="http://guide.couchdb.org/editions/1/en/views.html" target="_blank">CouchDB <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a> Book for more details). My favorite method is to use a client-side tool
    such as <code>couchapp</code> or <code>couchdbkit</code> that allows me to organize <code>map.js</code> and <code>reduce.js</code> files according to a filesystem hierarchy and then automatically upload them to the database as a design document. I
    actually snuck that two-liner into
    <a href="https://github.com/mlmiller/examples/blob/master/aviation/upload.py#L20" target="_blank"><code>upload.py</code> <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>, where I have:</p>
  <pre class="codeblock"><code class="lang-python hljs">loader = FileSystemDocsLoader(<span class="hljs-string">'_design/'</span>)
loader.sync(db, verbose=<span class="hljs-keyword">True</span>)
</code></pre>
  <p>Those two lines unpack the contents of the <code>_design directory</code> and build a design document. That directory looks like:<br>
    <img src="images/folders.png" alt="Folders"></p>
  <p>This gives me a design document with the name <code>example</code>; that contains two views, one called <code>date</code> and one called <code>make</code>. You can see the entire design document from the command line via:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET http://mlmiller.cloudant.com/planes/_design/example
</code></pre>
  <p>or you can just browse the &#39;<code>_design</code>&#39; code in the file <code>_design/example/views/make/map.js</code>. The code looks like this:</p>
  <pre class="codeblock"><code class="lang-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
    emit(doc.Make, <span class="hljs-number">1</span>);
}
</code></pre>
  <p>The <code>emit()</code> function generates a key/value pair that gets sorted according to CouchDB&#39;s deterministic
    <a href="http://wiki.apache.org/couchdb/View_collation#Collation_Specification" target="_blank">collation order <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>. These key/value pairs are either stored
    directly in the view index, or passed through the reducer first (see below). Don&#39;t worry about the second argument to the emit method, that&#39;s for the the reduce phase and we don&#39;t need that for a basic sort. The moment that we upload that
    design document to Cloudant, the index is kept up to date automatically. That&#39;s quite different than the default CouchDB behavior, but it&#39;s a nice optimization to make sure that the query response is snappy.</p>
  <p>Query (finally!). Let&#39;s find all of the documents (&#39;rows&#39;) that have <code>doc.Make==&quot;Cessna&quot;</code>. Since we emitted <code>doc.Make</code> in our map code,
    <code>doc.Make</code> is therefore the &#39;key&#39; for this index, and that means we get snappy responses to queries like:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://mlmiller.cloudant.com/planes/_design/example/_view/make?reduce=false&amp;key="Cessna"&amp;limit=10'</span>
{<span class="hljs-string">"total_rows"</span>:68387,<span class="hljs-string">"offset"</span>:13905,<span class="hljs-string">"rows"</span>:[
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"0fedbabcd21f15785750457f8300324c"</span>,<span class="hljs-string">"key"</span>:<span class="hljs-string">"Cessna"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"0fedbabcd21f15785750457f83003a2f"</span>,<span class="hljs-string">"key"</span>:<span class="hljs-string">"Cessna"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"0fedbabcd21f15785750457f830060ec"</span>,<span class="hljs-string">"key"</span>:<span class="hljs-string">"Cessna"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"0fedbabcd21f15785750457f83006bfb"</span>,<span class="hljs-string">"key"</span>:<span class="hljs-string">"Cessna"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"0fedbabcd21f15785750457f8300a5ae"</span>,<span class="hljs-string">"key"</span>:<span class="hljs-string">"Cessna"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"0fedbabcd21f15785750457f8300e15d"</span>,<span class="hljs-string">"key"</span>:<span class="hljs-string">"Cessna"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"0fedbabcd21f15785750457f830162b7"</span>,<span class="hljs-string">"key"</span>:<span class="hljs-string">"Cessna"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"0fedbabcd21f15785750457f8301a3a4"</span>,<span class="hljs-string">"key"</span>:<span class="hljs-string">"Cessna"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"0fedbabcd21f15785750457f8301a54e"</span>,<span class="hljs-string">"key"</span>:<span class="hljs-string">"Cessna"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"0fedbabcd21f15785750457f83058740"</span>,<span class="hljs-string">"key"</span>:<span class="hljs-string">"Cessna"</span>,<span class="hljs-string">"value"</span>:1}
]}
</code></pre>
  <p>The full list of query options is
    <a href="http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options" target="_blank">given here <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>, but really there are only a handful of options I typically
    use. For this query, if you remove the <code>limit</code> argument you will get the entire list of crashes with a Cessna involved. If you want to do some fun statistics, you can try:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://mlmiller.cloudant.com/planes/_design/example/_view/make?reduce=false&amp;key="Airbus"'</span> | wc <span class="hljs-_">-l</span> 15
</code></pre>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://mlmiller.cloudant.com/planes/_design/example/_view/make?reduce=false&amp;key="Boeing"'</span> | wc <span class="hljs-_">-l</span> 773
</code></pre>
  <p>Well that&#39;s interesting! But wait, isn&#39;t there a more efficient way to calculate statistics than slurping the entire set of Boeing lines to the client and doing a client-side count? You bet, and that&#39;s where reduce comes in.</p>
  <h2 id="example-2-data-aggregation">Example 2: Data Aggregation</h2>
  <p>Now we want to go beyond simple sorts and aggregate to find the total number of crashes for different types of planes. Reduce is perfect for this, and that&#39;s why we did <code>emit(doc.Make,1)</code> in <code>map.js</code>. If you look at the corresponding
    <a href="https://github.com/mlmiller/examples/blob/master/aviation/_design/example/views/make/reduce.js" target="_blank"><code>reduce.js</code> <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a> file for
    that view you&#39;ll see nothing more than: <code>_sum</code>.</p>
  <p>What is that? Well there are certain aggregation tasks that are simply so common (count, sum, average, min, max, etc.) that we have coded them up in erlang and pushed them into the database. Cloudant has an ever growing number of built-in reduces, and
    using a builtin is always faster and less error prone than writing it yourself. As an avid user, I can admit that I haven&#39;t used a non-builtin reduce in at least 9 months. So the <code>_sum</code> that we use here is simply going to add up the
    numbers that we emitted as the 2nd argument to <code>emit()</code> in the <code>map.js</code> function. Now we can answer the Boeing vs. Airbus question without any client side work via:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://mlmiller.cloudant.com/planes/_design/example/_view/make?key="Boeing"'</span>
{<span class="hljs-string">"rows"</span>:[
{<span class="hljs-string">"key"</span>:null,<span class="hljs-string">"value"</span>:771}
]}
</code></pre>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://mlmiller.cloudant.com/planes/_design/example/_view/make?key="Airbus"'</span>
{<span class="hljs-string">"rows"</span>:[
{<span class="hljs-string">"key"</span>:null,<span class="hljs-string">"value"</span>:13}
]}
</code></pre>
  <p>Check that out! Hmm, now suppose I want to find the total number of accidents, I can then just do:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://mlmiller.cloudant.com/planes/_design/example/_view/make'</span>
{<span class="hljs-string">"rows"</span>:[
{<span class="hljs-string">"key"</span>:null,<span class="hljs-string">"value"</span>:68387}
]}
</code></pre>
  <p>Very cool, and if I want to make a graph of how they plot out vs manufacture I can add the <code>group=true</code> option:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://mlmiller.cloudant.com/planes/_design/example/_view/make?group=true'</span>
{<span class="hljs-string">"rows"</span>:[
{<span class="hljs-string">"key"</span>:<span class="hljs-string">""</span>,<span class="hljs-string">"value"</span>:53},
{<span class="hljs-string">"key"</span>:<span class="hljs-string">"107.5 Flying Corporation"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"key"</span>:<span class="hljs-string">"1200"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"key"</span>:<span class="hljs-string">"1977 COLFER-CHAN"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"key"</span>:<span class="hljs-string">"1ST FTR GP"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"key"</span>:<span class="hljs-string">"2000 McCoy"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"key"</span>:<span class="hljs-string">"2001 MCGIRL"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"key"</span>:<span class="hljs-string">"2003 Nash"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"key"</span>:<span class="hljs-string">"2007 Savage Air LLC"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"key"</span>:<span class="hljs-string">"67 FLYING DUTCHMAN"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"key"</span>:<span class="hljs-string">"85 MANISTA"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"key"</span>:<span class="hljs-string">"A Pair of Jacks"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"key"</span>:<span class="hljs-string">"A. H. GETTINGS"</span>,<span class="hljs-string">"value"</span>:1},
{<span class="hljs-string">"key"</span>:<span class="hljs-string">"A. LE FRANCOIS"</span>,<span class="hljs-string">"value"</span>:1},
...
</code></pre>
  <p>(truncated because it&#39;s a looong list!)</p>
  <p>Ok, so aggregation seems pretty straightforward. Now let&#39;s go the last step to time-series.</p>
  <h2 id="example-3-time-series-analysis">Example 3: Time Series Analysis</h2>
  <p>Let&#39;s get a bit more numerical and ask, what&#39;s the distribution of crashes and fatalities vs time. That&#39;s what the <code>date</code> view is for. If you inspect any of our crash documents you will see that they have a two other important
    fields:
    <code>Event Date</code> and <code>Total Fatal Injuries</code>. Let&#39;s create an index that allows us to answer time-based queries about both the number of accidents and the number of fatalities. While a bit morbid, it&#39;s good to know what the
    odds are! This example is a bit more complex because we are going to use an array for both arguments of <code>emit()</code>. Take a look at the code in the
    <a href="https://github.com/mlmiller/examples/blob/master/aviation/_design/example/views/date/map.js" target="_blank"><code>map.js</code> <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>:</p>
  <pre class="codeblock"><code class="lang-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
    <span class="hljs-keyword">var</span> then = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.parse(doc[<span class="hljs-string">'Event Date'</span>]));
    <span class="hljs-keyword">var</span> fatalities = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (doc[<span class="hljs-string">'Total Fatal Injuries'</span>]!=<span class="hljs-string">""</span>) {
        fatalities = <span class="hljs-built_in">parseInt</span>(doc[<span class="hljs-string">'Total Fatal Injuries'</span>]);
    }
    emit([then.getFullYear(), then.getMonth()], [<span class="hljs-number">1</span>, fatalities]);
}
</code></pre>
  <p>This is a bit more complex because we do some processing of the data. In line #2 we unpack the <code>Event Date</code> variable into a JavaScript Date object, very handy. I find myself using <code>new Date(Date.parse(some_weird_timestamp))</code> all
    the time. Line #6 simply casts our fatalities info into an integer. The magic is in <code>emit</code>, where we use JavaScript arrays <code>[]</code> for both the key and the value. Then, for reduce we use good ol&#39; <code>_sum</code>. One of Cloudant&#39;s
    additional builtins is a <code>_sum</code> that works on arrays, very handy. Now to query this index we get rows that are sorted by year, then month. The index looks like:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://mlmiller.cloudant.com/planes/_design/example/_view/date?group_level=2'</span> | more
{<span class="hljs-string">"rows"</span>:[
{<span class="hljs-string">"key"</span>:[1982,0],<span class="hljs-string">"value"</span>:[207,185]},
{<span class="hljs-string">"key"</span>:[1982,1],<span class="hljs-string">"value"</span>:[232,96]},
{<span class="hljs-string">"key"</span>:[1982,2],<span class="hljs-string">"value"</span>:[280,95]},
{<span class="hljs-string">"key"</span>:[1982,3],<span class="hljs-string">"value"</span>:[303,113]},
{<span class="hljs-string">"key"</span>:[1982,4],<span class="hljs-string">"value"</span>:[387,133]},
{<span class="hljs-string">"key"</span>:[1982,5],<span class="hljs-string">"value"</span>:[349,106]},
{<span class="hljs-string">"key"</span>:[1982,6],<span class="hljs-string">"value"</span>:[433,283]},
{<span class="hljs-string">"key"</span>:[1982,7],<span class="hljs-string">"value"</span>:[399,96]},
{<span class="hljs-string">"key"</span>:[1982,8],<span class="hljs-string">"value"</span>:[332,119]},
{<span class="hljs-string">"key"</span>:[1982,9],<span class="hljs-string">"value"</span>:[239,129]},
{<span class="hljs-string">"key"</span>:[1982,10],<span class="hljs-string">"value"</span>:[224,134]},
{<span class="hljs-string">"key"</span>:[1982,11],<span class="hljs-string">"value"</span>:[208,96]},
{<span class="hljs-string">"key"</span>:[1983,0],<span class="hljs-string">"value"</span>:[199,102]},
{<span class="hljs-string">"key"</span>:[1983,1],<span class="hljs-string">"value"</span>:[210,72]},
{<span class="hljs-string">"key"</span>:[1983,2],<span class="hljs-string">"value"</span>:[264,91]},
...
</code></pre>
  <p>So, e.g., 1982 month 0 (January) had 207 crashes and 185 fatalities. What was that group_level command? Let&#39;s try changing it:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://mlmiller.cloudant.com/planes/_design/example/_view/date?group_level=1'</span> | more
{<span class="hljs-string">"rows"</span>:[
{<span class="hljs-string">"key"</span>:[1982],<span class="hljs-string">"value"</span>:[3593,1585]},
{<span class="hljs-string">"key"</span>:[1983],<span class="hljs-string">"value"</span>:[3556,1273]},
{<span class="hljs-string">"key"</span>:[1984],<span class="hljs-string">"value"</span>:[3457,1229]},
{<span class="hljs-string">"key"</span>:[1985],<span class="hljs-string">"value"</span>:[3096,1648]},
{<span class="hljs-string">"key"</span>:[1986],<span class="hljs-string">"value"</span>:[2880,1180]},
{<span class="hljs-string">"key"</span>:[1987],<span class="hljs-string">"value"</span>:[2828,1237]},
...
</code></pre>
  <p>Well that&#39;s interesting!
    <code>group_level=1</code> vs <code>2</code> has a big effect: with <code>group_level=2</code> we get the full granularity/dimensionality of the array we used for the key (first argument to emit). But we can, at query time, reduce even further by
    integrating over month! Very cool, and the gory details are few:
    <code>group_level</code> runs between <code>0</code> and <code>length(key)</code>, so in this case valid values are 0, 1, 2. If we specify <code>group_level=0</code>, we&#39;ll get sum statistics over the entire date range:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://mlmiller.cloudant.com/planes/_design/example/_view/date?group_level=0'</span>
{<span class="hljs-string">"rows"</span>:[
{<span class="hljs-string">"key"</span>:null,<span class="hljs-string">"value"</span>:[68387,38652]}
]}
</code></pre>
  <p>Awesome. And therein lies the power of using MapReduce for an efficient index build. With Cloudant you don&#39;t need to install any software, you simply use the cloud hosted cluster to run your code. If you think about it, all we really had to do was
    write 9 lines of javascript for the map method, and no original code for the reduce method. We can use this same exact index to query for a given date range, say 1994:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://mlmiller.cloudant.com/planes/_design/example/_view/date?group_level=2&amp;startkey=\[1994\]&amp;endkey=\[1995\]'</span>
{<span class="hljs-string">"rows"</span>:[
{<span class="hljs-string">"key"</span>:[1994,0],<span class="hljs-string">"value"</span>:[116,60]},
{<span class="hljs-string">"key"</span>:[1994,1],<span class="hljs-string">"value"</span>:[142,42]},
{<span class="hljs-string">"key"</span>:[1994,2],<span class="hljs-string">"value"</span>:[191,67]},
{<span class="hljs-string">"key"</span>:[1994,3],<span class="hljs-string">"value"</span>:[179,72]},
{<span class="hljs-string">"key"</span>:[1994,4],<span class="hljs-string">"value"</span>:[224,74]},
{<span class="hljs-string">"key"</span>:[1994,5],<span class="hljs-string">"value"</span>:[223,98]},
{<span class="hljs-string">"key"</span>:[1994,6],<span class="hljs-string">"value"</span>:[267,131]},
{<span class="hljs-string">"key"</span>:[1994,7],<span class="hljs-string">"value"</span>:[260,101]},
{<span class="hljs-string">"key"</span>:[1994,8],<span class="hljs-string">"value"</span>:[212,200]},
{<span class="hljs-string">"key"</span>:[1994,9],<span class="hljs-string">"value"</span>:[169,129]},
{<span class="hljs-string">"key"</span>:[1994,10],<span class="hljs-string">"value"</span>:[131,79]},
{<span class="hljs-string">"key"</span>:[1994,11],<span class="hljs-string">"value"</span>:[143,130]}
]}
</code></pre>
  <p>or if we want to do can turn off the reduce in the query and get all of the crashes from a given year/month combo:</p>
  <pre class="pre"><code class="lang-sh hljs">curl -X GET <span class="hljs-string">'http://mlmiller.cloudant.com/planes/_design/example/_view/date?key=\[1994,4\]&amp;reduce=false'</span> | more
{<span class="hljs-string">"total_rows"</span>:68387,<span class="hljs-string">"offset"</span>:34959,<span class="hljs-string">"rows"</span>:[
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"88601d815897032516f87f0c510c7c60"</span>,<span class="hljs-string">"key"</span>:[1994,4],<span class="hljs-string">"value"</span>:[1,1]},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"88601d815897032516f87f0c510c87b7"</span>,<span class="hljs-string">"key"</span>:[1994,4],<span class="hljs-string">"value"</span>:[1,0]},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"88601d815897032516f87f0c510c951a"</span>,<span class="hljs-string">"key"</span>:[1994,4],<span class="hljs-string">"value"</span>:[1,2]},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"88601d815897032516f87f0c510c9b0a"</span>,<span class="hljs-string">"key"</span>:[1994,4],<span class="hljs-string">"value"</span>:[1,0]},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"88601d815897032516f87f0c510c9bbb"</span>,<span class="hljs-string">"key"</span>:[1994,4],<span class="hljs-string">"value"</span>:[1,0]},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"88601d815897032516f87f0c510c9c15"</span>,<span class="hljs-string">"key"</span>:[1994,4],<span class="hljs-string">"value"</span>:[1,1]},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"88601d815897032516f87f0c510c9d6d"</span>,<span class="hljs-string">"key"</span>:[1994,4],<span class="hljs-string">"value"</span>:[1,0]},
{<span class="hljs-string">"id"</span>:<span class="hljs-string">"88601d815897032516f87f0c510ca925"</span>,<span class="hljs-string">"key"</span>:[1994,4],<span class="hljs-string">"value"</span>:[1,0]},
...
</code></pre>
  <p>Wow, handy! And if you want to really blow your mind, add the query-string parameter <code>?include_docs=true</code> to get the full documents themselves.</p>
  <h2 id="summary">Summary</h2>
  <p>There&#39;s a lot of power in MapReduce, and I hope I&#39;ve given you enough to get your hands dirty running it an an extremely simple way using a hosted service. If you have more questions, there are lots of examples on the
    <a href="http://wiki.apache.org/couchdb/" target="_blank">CouchDB wiki <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a> or in the <a href="../index.html">Cloudant documentation</a>. But the rule of thumb
    is:</p>
  <ul>
    <li><strong>sort:</strong> map only</li>
    <li><strong>aggregate:</strong> use a <code>_sum</code> reduce + <code>group_level</code></li>
    <li><strong>time-series:</strong> use an array of <code>[year, month, day, ...]</code> + <code>group_level</code></li>
  </ul>
  <footer>
    <div>
      <p>Copyright &copy; 2015, 2017. All Rights Reserved.</p>
    </div>
  </footer>
</body>
</html>