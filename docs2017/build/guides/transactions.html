<html lang="en">
<head>
  <title>IBM&reg; Cloudant&reg; NoSQL DB for Bluemix&reg;</title>
  <meta charset="utf-8"></meta>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
</head>

<body>
  <h1 id="grouping-related-documents-together-in-cloudant">Grouping related documents together in Cloudant</h1>
  <p>Traditionally, e-commerce systems are built with relational databases. These databases typically use a number of tables joined together to record sales, customer details, purchased products, and delivery tracking information. Relational databases offer
    high consistency meaning that application developers can build their applications to a database&#39;s strengths, including using joins between collections, enumerations to record the state of an object, and database transactions to guarantee atomic
    operations.</p>
  <p>Cloudant favors availability over consistency. It is a high-availability, fault-tolerant, distributed database that is eventually consistent. This gives the advantage that the customer&#39;s shopping service is always available and scalable enough to
    cope with multiple users making purchases at the same time. This means that your application can utilize Cloudant&#39;s strengths and not treat it like a relational database.</p>
  <p>The discussion in this topic outlines some of the factors involved in building an e-commerce system that takes advantage of Cloudant&#39;s strengths, using concepts that are applicable to many other domains, such as:</p>
  <ul>
    <li>Using multiple documents to represent the state of a purchase, rather than frequently updating a single document.</li>
    <li>Storing copies of related objects in order instead of joining to another collection.</li>
    <li>Creating views to collate documents by <code>order_id</code> to reflect the current state of a purchase.</li>
  </ul>
  <p>For example, you might create a <code>purchase</code> document that contains details such as the items ordered, customer information, cost, and delivery information.</p>
  <p><em>Example document describing a purchase:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"023f7a21dbe8a4177a2816e4ad1ea27e"</span>,
    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"purchase"</span>,
    <span class="hljs-attr">"order_id"</span>: <span class="hljs-string">"320afa89017426b994162ab004ce3383"</span>,
    <span class="hljs-attr">"basket"</span>: [
        {
            <span class="hljs-attr">"product_id"</span>: <span class="hljs-string">"A56"</span>,
            <span class="hljs-attr">"title"</span>: <span class="hljs-string">"Adele - 25"</span>,
            <span class="hljs-attr">"category"</span>: <span class="hljs-string">"Audio CD"</span>,
            <span class="hljs-attr">"price"</span>: <span class="hljs-number">8.33</span>,
            <span class="hljs-attr">"tax"</span>: <span class="hljs-number">0.2</span>,
            <span class="hljs-attr">"quantity"</span>: <span class="hljs-number">2</span>
        },
        {
            <span class="hljs-attr">"product_id"</span>: <span class="hljs-string">"B32"</span>,
            <span class="hljs-attr">"title"</span>: <span class="hljs-string">"The Lady In The Van - Alan Bennett"</span>,
            <span class="hljs-attr">"category"</span>: <span class="hljs-string">"Paperback book"</span>,
            <span class="hljs-attr">"price"</span>: <span class="hljs-number">3.49</span>,
            <span class="hljs-attr">"tax"</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">"quantity"</span>: <span class="hljs-number">2</span>
        }
    ],
    <span class="hljs-attr">"account_id"</span>: <span class="hljs-string">"985522332"</span>,
    <span class="hljs-attr">"delivery"</span>: {
        <span class="hljs-attr">"option"</span>: <span class="hljs-string">"Next Day"</span>,
        <span class="hljs-attr">"price"</span>: <span class="hljs-number">2.99</span>,
        <span class="hljs-attr">"address"</span>: {
            <span class="hljs-attr">"street"</span>: <span class="hljs-string">"17 Front Street"</span>,
            <span class="hljs-attr">"town"</span>: <span class="hljs-string">"Middlemarch"</span>,
            <span class="hljs-attr">"postcode"</span>: <span class="hljs-string">"W1A 1AA"</span>
        }
    },
    <span class="hljs-attr">"pretax"</span> : <span class="hljs-number">20.15</span>,
    <span class="hljs-attr">"tax"</span> : <span class="hljs-number">3.32</span>,
    <span class="hljs-attr">"total"</span>: <span class="hljs-number">26.46</span>
}
</code></pre>
  <p>This document provides enough data for a purchase record to render a summary of an order on a web page, or an email, without fetching additional records. Notice key details about the order, in particular:</p>
  <ul>
    <li>The basket contains reference ids (<code>product_id</code>) to a database of products stored elsewhere.</li>
    <li>The basket duplicates some of the product data in this record, enough to record the state of the items purchased at the point of sale.</li>
    <li>The document does not contain fields that mark the status of the order. Additional documents would be added later to record payments and delivery.</li>
    <li>The database automatically generates a document <code>_id</code> when it inserts the document into the database.</li>
    <li>A unique identifier (<code>order_id</code>) is supplied with each purchase record to reference the order later. </li>
  </ul>
  <p>When the customer places an order, typically at the point when they enter the &quot;checkout&quot; phase on the website, a purchase order record is created similar to the previous example. </p>
  <h2 id="generating-your-own-unique-identifiers-uuids-">Generating your own unique identifiers (UUIDs)</h2>
  <p>In a relational database, sequential &quot;auto incrementing&quot; numbers are often used, but in distributed databases, where data is spread around of cluster of servers, longer UUIDs are used to ensure that documents are stored with their own unique
    id.</p>
  <p>To create a unique identifier for use in your application, such as an <code>order_id</code>, call the <a href="../api/advanced.html#-get-_uuids-"><code>GET _uuids</code> endpoint</a> on the Cloudant API. The database generates an identifier for you.
    The same endpoint can be used to generate multiple ids by adding a <code>count</code> parameter, for example, <code>/_uuids?count=10</code>.</p>
  <h2 id="recording-payments">Recording payments</h2>
  <p>When the customer successfully pays for their items, additional records are added to the database to record the order.</p>
  <p><em>Example of a payment record:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    &quot;_id&quot;: &quot;bf70c30ea5d8c3cd088fef98ad678e9e&quot;,
    &quot;type&quot;: &quot;payment&quot;,
    &quot;account_id&quot;: &quot;985522332&quot;,
    &quot;order_id&quot;: &quot;320afa89017426b994162ab004ce3383&quot;,
    &quot;value&quot;: 6.46,
    &quot;method&quot;: &quot;credit card&quot;,
    &quot;payment_reference&quot;: &quot;AB9977G244FF2F667&quot;
}
...
{
    &quot;_id&quot;: &quot;12c0ea6cd3d2c6e3b1d34442aea6a2d9&quot;,
    &quot;type&quot;: &quot;payment&quot;,
    &quot;account_id&quot;: &quot;985522332&quot;,
    &quot;order_id&quot;: &quot;320afa89017426b994162ab004ce3383&quot;,
    &quot;value&quot;: 20.00,
    &quot;method&quot;: &quot;voucher&quot;,
    &quot;payment_reference&quot;: &quot;Q88775662377224&quot;
}
</code></pre>
  <p>In the previous example, the customer paid by supplying a credit card and redeeming a pre-paid voucher. The total of the two payments added up to the amount of the order. Each payment was written to Cloudant as a separate document.</p>
  <p>You could see the status of an order by creating a view of everything you know about an <code>order_id</code>. The view would enable a ledger containing the following information: </p>
  <ul>
    <li>Purchase totals as positive numbers.</li>
    <li>Payments against the account as negative numbers.</li>
  </ul>
  <p>A map function could be used to identify the required values.</p>
  <p><em>Example map function to find purchase total and payment values:</em> </p>
  <pre class="codeblock"><code class="lang-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
    <span class="hljs-keyword">if</span> (doc.type === <span class="hljs-string">'purchase'</span>) {
        emit(doc.order_id, doc.total);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (doc.type === <span class="hljs-string">'payment'</span>) {
            emit(doc.order_id, -doc.value);
        }
    }
}
</code></pre>
  <p>Using the built-in <a href="../api/creating_views.html#built-in-reduce-functions"><code>_sum</code> reducer</a> enables you to produce output as a ledger of payment events.</p>
  <p><em>Example of using the built-in <code>_sum</code> reducer, queried with <code>?reduce=false</code>:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"total_rows"</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">"offset"</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">"rows"</span>:[
        {
            <span class="hljs-attr">"id"</span>:<span class="hljs-string">"320afa89017426b994162ab004ce3383"</span>,
            <span class="hljs-attr">"key"</span>:<span class="hljs-string">"985522332"</span>,
            <span class="hljs-attr">"value"</span>:<span class="hljs-number">26.46</span>
        },
        {
            <span class="hljs-attr">"id"</span>:<span class="hljs-string">"320afa89017426b994162ab004ce3383"</span>,
            <span class="hljs-attr">"key"</span>:<span class="hljs-string">"985522332"</span>,
            <span class="hljs-attr">"value"</span>:<span class="hljs-number">-20</span>
        },
        {
            <span class="hljs-attr">"id"</span>:<span class="hljs-string">"320afa89017426b994162ab004ce3383"</span>,
            <span class="hljs-attr">"key"</span>:<span class="hljs-string">"985522332"</span>,
            <span class="hljs-attr">"value"</span>:<span class="hljs-number">-6.46</span>
        }
    ]
}
</code></pre>
  <p>Alternatively, you could produce totals grouped by <code>order_id</code>.</p>
  <p><em>Example of totals grouped by <code>order_id</code>, with <code>?group_level=1</code>:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"rows"</span>:[
        {
            <span class="hljs-attr">"key"</span>:<span class="hljs-string">"320afa89017426b994162ab004ce3383"</span>,
            <span class="hljs-attr">"value"</span>:<span class="hljs-number">0</span>
        }
    ]
}
</code></pre>
  <p>Since the view in previous example returns 0 for the order value, the result indicates that the order is fully paid. The reason is that the positive purchase order total cancels out the negative payment amounts. Recording events as separate documents,
    that is one for the order and one for each payment, is good practice in Cloudant, since it avoids the possibility of creating conflicts when multiple processes modify the same document simultaneously.</p>
  <h2 id="adding-additional-documents">Adding additional documents</h2>
  <p>You could add other, separate documents to the database to record the following state changes as the order is provisioned and dispatched:</p>
  <ul>
    <li>Dispatch notifications.</li>
    <li>Delivery receipts.</li>
    <li>Refund records.</li>
  </ul>
  <p>As the data arrives, Cloudant writes to each document separately. Therefore, it is not necessary to modify the core purchase document.</p>
  <h2 id="advantages-of-storing-purchase-orders-in-cloudant">Advantages of storing purchase orders in Cloudant</h2>
  <p>Using Cloudant to store purchase order information allows an ordering system to be highly available and scalable, enabling you to deal with large volumes of data and high rates of concurrent access. By modeling the data in separate documents that are
    only written once, we can ensure that documents never become conflicted, such as during concurrent access to the same document by separate processes.</p>
  <p>Furthermore, documents can contain copies of data that exists in other collections to represent - rather than rely on - joining data with a foreign key. For example, when recording the state of a basket at the time of purchase. This allows an order&#39;s
    state to be fetched by a single call to a Cloudant&#39;s view that groups documents related by <code>order_id</code>.</p>
  <footer>
    <div>
      <p>Copyright &copy; 2015, 2017. All Rights Reserved.</p>
    </div>
  </footer>
</body>
</html>