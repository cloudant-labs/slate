<html lang="en">
<head>
  <title>IBM&reg; Cloudant&reg; NoSQL DB for Bluemix&reg;</title>
  <meta charset="utf-8"></meta>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
</head>

<body>
  <!-- Acrolinx: 2017-01-13 -->

  <h1 id="search">Search</h1>
  <p class="shortdesc">Search indexes, which are defined in design documents, allow databases to be queried by using
    <a href="http://lucene.apache.org/core/4_3_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#Overview" target="_blank">Lucene Query Parser Syntax <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>.</p>
  <p>Search indexes are defined by an index function, similar to a map function in <a href="creating_views.html#creating-views">MapReduce views</a>. The index function decides what data to index and store in the index.</p>
  <p><em>Example design document that defines a search index:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"_design/search_example"</span>,
    <span class="hljs-attr">"indexes"</span>: {
        <span class="hljs-attr">"animals"</span>: {
            <span class="hljs-attr">"index"</span>: <span class="hljs-string">"function(doc){ ... }"</span>
        }
    }
}
</code></pre>
  <h2 id="index-functions">Index functions</h2>
  <blockquote>
    <p> <strong>Note</strong>: Attempting to index by using a data field that does not exist fails. To avoid this problem, use an appropriate <a href="#index-guard-clauses">guard clause</a>.</p>
  </blockquote>
  <p>The function that is contained in the index field is a JavaScript function that is called for each document in the database. The function takes the document as a parameter, extracts some data from it, and then calls the function that is defined in the
    <code>index</code> field to index that data.</p>
  <p>The <code>index</code> function takes three parameters, where the third parameter is optional.</p>
  <p>The first parameter is the name of the field you intend to use when querying the index, and which is specified in the Lucene syntax portion of subsequent queries. An example appears in the following query:</p>
  <pre class="codeblock"><code class="hljs">query=color:red
</code></pre>
  <p>The Lucene field name <code>color</code> is the first parameter of the <code>index</code> function.</p>
  <p>The <code>query</code> parameter can be abbreviated to <code>q</code>, so another way of writing the query is as follows:</p>
  <pre class="codeblock"><code class="hljs">q=color:red
</code></pre>
  <p>If the special value <code>&quot;default&quot;</code> is used when you define the name, you do not have to specify a field name at query time. The effect is that the query can be simplified:</p>
  <pre class="codeblock"><code class="hljs">query=red
</code></pre>
  <p>The second parameter is the data to be indexed.</p>
  <p>The third, optional parameter is a JavaScript object with the following fields:</p>
  <table border="1">

    <tr>
      <th>Option</th>
      <th>Description</th>
      <th>Values</th>
      <th>Default</th>
    </tr>
    <tr>
      <td><code>boost</code></td>
      <td>A number that specifies the relevance in search results. Content that is indexed with a boost value greater than 1 is more relevant than content that is indexed without a boost value. Content with a boost value less than one is not so relevant.</td>
      <td>A positive floating point number</td>
      <td>1 (no boosting)</td>
    </tr>
    <tr>
      <td><code>facet</code></td>
      <td>Creates a faceted index. For more information, see <a href="#faceting">Faceting</a>.</td>
      <td><code>true</code>,
        <code>false</code></td>
      <td><code>false</code></td>
    </tr>
    <tr>
      <td><code>index</code></td>
      <td>Whether the data is indexed, and if so, how. If set to <code>false</code> or <code>no</code>, the data cannot be used for searches, but can still be retrieved from the index if <code>store</code> is set to <code>true</code>. For more information,
        see <a href="#analyzers">Analyzers</a>.</td>
      <td><code>analyzed</code>,
        <code>analyzed_no_norms</code>,
        <code>false</code>,
        <code>no</code>,
        <code>not_analyzed</code>,
        <code>not_analyzed_no_norms</code></td>
      <td><code>analyzed</code></td>
    </tr>
    <tr>
      <td><code>store</code></td>
      <td>If <code>true</code>, the value is returned in the search result; otherwise, the value is not returned.</td>
      <td><code>true</code>,
        <code>false</code></td>
      <td><code>false</code></td>
    </tr>
  </table>
  <blockquote>
    <p> <strong>Note</strong>: If you do not set the <code>store</code> parameter, the index data results for the document are not returned in response to a query.</p>
  </blockquote>
  <p><em>Example search index function:</em></p>
  <pre class="codeblock"><code class="lang-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
    index(<span class="hljs-string">"default"</span>, doc._id);
    <span class="hljs-keyword">if</span> (doc.min_length) {
        index(<span class="hljs-string">"min_length"</span>, doc.min_length, {<span class="hljs-string">"store"</span>: <span class="hljs-literal">true</span>});
    }
    <span class="hljs-keyword">if</span> (doc.diet) {
        index(<span class="hljs-string">"diet"</span>, doc.diet, {<span class="hljs-string">"store"</span>: <span class="hljs-literal">true</span>});
    }
    <span class="hljs-keyword">if</span> (doc.latin_name) {
        index(<span class="hljs-string">"latin_name"</span>, doc.latin_name, {<span class="hljs-string">"store"</span>: <span class="hljs-literal">true</span>});
    }
    <span class="hljs-keyword">if</span> (doc.class) {
        index(<span class="hljs-string">"class"</span>, doc.class, {<span class="hljs-string">"store"</span>: <span class="hljs-literal">true</span>});
    }
}
</code></pre>
  <h3 id="index-guard-clauses">Index Guard Clauses</h3>
  <p>The <code>index</code> function requires the name of the data field to index as the second parameter. However, if that data field does not exist for the document, an error occurs. The solution is to use an appropriate &#39;guard clause&#39; that checks
    if the field exists, and contains the expected type of data,
    <em>before</em> any attempt to create the corresponding index.</p>
  <p><em>Example of failing to check whether the index data field exists:</em></p>
  <pre class="codeblock"><code class="lang-javascript hljs"><span class="hljs-keyword">if</span> (doc.min_length) {
    index(<span class="hljs-string">"min_length"</span>, doc.min_length, {<span class="hljs-string">"store"</span>: <span class="hljs-literal">true</span>});
}
</code></pre>
  <p>You might use the JavaScript &#39;<code>typeof</code>&#39; function to implement the guard clause test. If the field exists <em>and</em> has the expected type, the correct type name is returned, so the guard clause test succeeds and it is safe to use
    the index function. If the field does <em>not</em> exist, you would not get back the expected type of the field, therefore you would not attempt to index the field.</p>
  <p>JavaScript considers a result to be false if one of the following values is tested:</p>
  <ul>
    <li>&#39;undefined&#39;</li>
    <li>null</li>
    <li>The number +0</li>
    <li>The number -0</li>
    <li>NaN (not a number)</li>
    <li>&quot;&quot; (the empty string)</li>
  </ul>
  <p><em>Using a guard clause to check whether the required data field exists,
and holds a number,
before an attempt to index:</em></p>
  <pre class="codeblock"><code class="lang-javascript hljs"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(doc.min_length) === <span class="hljs-string">'number'</span>) {
    index(<span class="hljs-string">"min_length"</span>, doc.min_length, {<span class="hljs-string">"store"</span>: <span class="hljs-literal">true</span>});
}
</code></pre>
  <p>Use a generic guard clause test to ensure that the type of the candidate data field is defined.</p>
  <p><em>Example of a &#39;generic&#39; guard clause:</em></p>
  <pre class="codeblock"><code class="lang-javascript hljs"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(doc.min_length) !== <span class="hljs-string">'undefined'</span>) {
    <span class="hljs-comment">// The field exists, and does have a type, so we can proceed to index using it.</span>
    ...
}
</code></pre>
  <h2 id="analyzers">Analyzers</h2>
  <p>Analyzers are settings that define how to recognize terms within text. Analyzers can be helpful if you need to <a href="#language-specific-analyzers">index multiple languages</a>.</p>
  <p>Here&#39;s the list of generic analyzers that are supported by Cloudant search:</p>
  <table>
    <thead>
      <tr>
        <th>Analyzer</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>classic</code></td>
        <td>The standard Lucene analyzer, circa release 3.1.</td>
      </tr>
      <tr>
        <td><code>email</code></td>
        <td>Like the <code>standard</code> analyzer, but tries harder to match an email address as a complete token.</td>
      </tr>
      <tr>
        <td><code>keyword</code></td>
        <td>Input is not tokenized at all.</td>
      </tr>
      <tr>
        <td><code>simple</code></td>
        <td>Divides text at non-letters.</td>
      </tr>
      <tr>
        <td><code>standard</code></td>
        <td>The default analyzer. It implements the Word Break rules from the <a href="http://www.unicode.org/reports/tr29/" target="_blank">Unicode Text Segmentation algorithm <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>.</td>
      </tr>
      <tr>
        <td><code>whitespace</code></td>
        <td>Divides text at white space boundaries.</td>
      </tr>
    </tbody>
  </table>
  <p><em>Example analyzer document:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"_design/analyzer_example"</span>,
    <span class="hljs-attr">"indexes"</span>: {
        <span class="hljs-attr">"INDEX_NAME"</span>: {
            <span class="hljs-attr">"index"</span>: <span class="hljs-string">"function (doc) { ... }"</span>,
            <span class="hljs-attr">"analyzer"</span>: <span class="hljs-string">"$ANALYZER_NAME"</span>
        }
    }
}
</code></pre>
  <h3 id="language-specific-analyzers">Language-Specific Analyzers</h3>
  <p>These analyzers omit common words in the specific language, and many also <a href="http://en.wikipedia.org/wiki/Stemming" target="_blank">remove prefixes and suffixes <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>.
    The name of the language is also the name of the analyzer.</p>
  <ul>
    <li><code>arabic</code></li>
    <li><code>armenian</code></li>
    <li><code>basque</code></li>
    <li><code>bulgarian</code></li>
    <li><code>brazilian</code></li>
    <li><code>catalan</code></li>
    <li><code>cjk</code> (Chinese, Japanese, Korean)</li>
    <li><code>chinese</code> ( <a href="http://lucene.apache.org/core/4_2_1/analyzers-smartcn/org/apache/lucene/analysis/cn/smart/SmartChineseAnalyzer.html" target="_blank">smartcn <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>      )</li>
    <li><code>czech</code></li>
    <li><code>danish</code></li>
    <li><code>dutch</code></li>
    <li><code>english</code></li>
    <li><code>finnish</code></li>
    <li><code>french</code></li>
    <li><code>german</code></li>
    <li><code>greek</code></li>
    <li><code>galician</code></li>
    <li><code>hindi</code></li>
    <li><code>hungarian</code></li>
    <li><code>indonesian</code></li>
    <li><code>irish</code></li>
    <li><code>italian</code></li>
    <li><code>japanese</code> ( <a href="http://lucene.apache.org/core/4_2_1/analyzers-kuromoji/overview-summary.html" target="_blank">kuromoji <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a> )</li>
    <li><code>latvian</code></li>
    <li><code>norwegian</code></li>
    <li><code>persian</code></li>
    <li><code>polish</code> ( <a href="http://lucene.apache.org/core/4_2_1/analyzers-stempel/overview-summary.html" target="_blank">stempel <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a> )</li>
    <li><code>portuguese</code></li>
    <li><code>romanian</code></li>
    <li><code>russian</code></li>
    <li><code>spanish</code></li>
    <li><code>swedish</code></li>
    <li><code>thai</code></li>
    <li><code>turkish</code></li>
  </ul>
  <blockquote>
    <p> <strong>Note</strong>: Language-specific analyzers are optimized for the specified language. You cannot combine a generic analyzer with a language-specific analyzer. Instead, you might use a <a href="#per-field-analyzers">&#39;<code>perfield</code>&#39; analyzer</a>      to select different analyzers for different fields within the documents.</p>
  </blockquote>
  <h3 id="per-field-analyzers">Per-Field Analyzers</h3>
  <p>The &#39;<code>perfield</code>&#39; analyzer configures multiple analyzers for different fields.</p>
  <p><em>Example of defining different analyzers for different fields:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"_design/analyzer_example"</span>,
    <span class="hljs-attr">"indexes"</span>: {
        <span class="hljs-attr">"INDEX_NAME"</span>: {
            <span class="hljs-attr">"analyzer"</span>: {
                <span class="hljs-attr">"name"</span>: <span class="hljs-string">"perfield"</span>,
                <span class="hljs-attr">"default"</span>: <span class="hljs-string">"english"</span>,
                <span class="hljs-attr">"fields"</span>: {
                    <span class="hljs-attr">"spanish"</span>: <span class="hljs-string">"spanish"</span>,
                    <span class="hljs-attr">"german"</span>: <span class="hljs-string">"german"</span>
                }
            },
            <span class="hljs-attr">"index"</span>: <span class="hljs-string">"function (doc) { ... }"</span>
        }
    }
}
</code></pre>
  <h3 id="stop-words">Stop Words</h3>
  <p>Stop words are words that do not get indexed. You define them within a design document by turning the analyzer string into an object.</p>
  <blockquote>
    <p> <strong>Note</strong>: The <code>keyword</code>,
      <code>simple</code>, and <code>whitespace</code> analyzers do not support stop words.</p>
  </blockquote>
  <p><em>Example of defining non-indexed (&#39;stop&#39;) words:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"_design/stop_words_example"</span>,
    <span class="hljs-attr">"indexes"</span>: {
        <span class="hljs-attr">"INDEX_NAME"</span>: {
            <span class="hljs-attr">"analyzer"</span>: {
                <span class="hljs-attr">"name"</span>: <span class="hljs-string">"portuguese"</span>,
                <span class="hljs-attr">"stopwords"</span>: [
                    <span class="hljs-string">"foo"</span>,
                    <span class="hljs-string">"bar"</span>,
                    <span class="hljs-string">"baz"</span>
                ]
            },
            <span class="hljs-attr">"index"</span>: <span class="hljs-string">"function (doc) { ... }"</span>
        }
    }
}
</code></pre>
  <h3 id="testing-analyzer-tokenization">Testing analyzer tokenization</h3>
  <p>You can test the results of analyzer tokenization by posting sample data to the <code>_search_analyze</code> endpoint.</p>
  <p><em>Example of using HTTP to test the <code>keyword</code> analyzer:</em></p>
  <pre class="codeblock"><code class="lang-http hljs">Host: &lt;account&gt;.cloudant.com
POST /_search_analyze HTTP/1.1
Content-Type: application/json
{"analyzer":"keyword", "text":"ablanks@renovations.com"}
</code></pre>
  <p><em>Example of using the command line to test the <code>keyword</code> analyzer:</em></p>
  <pre class="codeblock"><code class="lang-sh hljs">curl <span class="hljs-string">'https://&lt;account&gt;.cloudant.com/_search_analyze'</span> -H <span class="hljs-string">'Content-Type: application/json'</span>
    <span class="hljs-_">-d</span> <span class="hljs-string">'{"analyzer":"keyword", "text":"ablanks@renovations.com"}'</span>
</code></pre>
  <p><em>Result of testing the <code>keyword</code> analyzer:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"tokens"</span>: [
        <span class="hljs-string">"ablanks@renovations.com"</span>
    ]
}
</code></pre>
  <p><em>Example of using HTTP to test the <code>standard</code> analyzer:</em></p>
  <pre class="codeblock"><code class="lang-http hljs">Host: &lt;account&gt;.cloudant.com
POST /_search_analyze HTTP/1.1
Content-Type: application/json
{"analyzer":"standard", "text":"ablanks@renovations.com"}
</code></pre>
  <p><em>Example of using the command line to test the <code>standard</code> analyzer:</em></p>
  <pre class="codeblock"><code class="lang-sh hljs">curl <span class="hljs-string">'https://&lt;account&gt;.cloudant.com/_search_analyze'</span> -H <span class="hljs-string">'Content-Type: application/json'</span>
    <span class="hljs-_">-d</span> <span class="hljs-string">'{"analyzer":"standard", "text":"ablanks@renovations.com"}'</span>
</code></pre>
  <p><em>Result of testing the <code>standard</code> analyzer:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"tokens"</span>: [
        <span class="hljs-string">"ablanks"</span>,
        <span class="hljs-string">"renovations.com"</span>
    ]
}
</code></pre>
  <h2 id="queries">Queries</h2>
  <p>After you create an index, you can query it with a <code>GET</code> request to
    <code>https://$USERNAME.cloudant.com/$DATABASE/_design/$DESIGN_ID/_search/$INDEX_NAME</code>. Specify your search by using the <code>query</code> parameter.</p>
  <p><em>Example of using HTTP to query an index:</em></p>
  <pre class="codeblock"><code class="lang-http hljs"><span class="hljs-keyword">GET</span> <span class="hljs-string">/$DATABASE/_design/$DESIGN_DOC/_search/$INDEX_NAME?include_docs=true\&amp;query="*:*"\&amp;limit=1</span> HTTP/1.1
<span class="hljs-attribute">Content-Type</span>: application/json
<span class="hljs-attribute">Host</span>: account.cloudant.com
</code></pre>
  <p><em>Example to using the command line to query an index:</em></p>
  <pre class="codeblock"><code class="lang-sh hljs">curl https://<span class="hljs-variable">$USERNAME</span>.cloudant.com/<span class="hljs-variable">$DATABASE</span>/_design/<span class="hljs-variable">$DESIGN_DOC</span>/_search/<span class="hljs-variable">$INDEX_NAME</span>?include_docs=<span class="hljs-literal">true</span>\&amp;query=<span class="hljs-string">"*:*"</span>\&amp;<span class="hljs-built_in">limit</span>=1 \
    -u <span class="hljs-variable">$USERNAME</span>
</code></pre>
  <!--

_Example of using JavaScript to query an index:_

```javascript
var nano = require('nano');
var account = nano("https://"+$USERNAME+":"+$PASSWORD+"@"+$USERNAME+".cloudant.com");
var db = account.use($DATABASE);

db.search($DESIGN_ID, $SEARCH_INDEX, {
    q: $QUERY
}, function (err, body, headers) {
    if (!err) {
        console.log(body);
    }
});
```

-->

  <h3 id="query-parameters">Query Parameters</h3>
  <blockquote>
    <p> <strong>Note</strong>: You must enable <a href="#faceting">faceting</a> before you can use the following parameters:</p>
    <pre><code class="hljs">-    `counts`
-    `drilldown`
</code></pre>
  </blockquote>
  <table border="1">

    <tr>
      <th>Argument</th>
      <th>Description</th>
      <th>Optional</th>
      <th>Type</th>
      <th>Supported Values</th>
    </tr>
    <tr>
      <td><code>bookmark</code></td>
      <td>A bookmark that was received from a previous search. This parameter enables paging through the results. If there are no more results after the bookmark, you get a response with an empty rows array and the same bookmark, confirming the end of the
        result list.</td>
      <td>yes</td>
      <td>string</td>
    </tr>
    <tr>
      <td><code>counts</code></td>
      <td>This field defines an array of names of string fields, for which counts are requested. The response contains counts for each unique value of this field name among the documents that match the search query.
        <a href="#faceting">Faceting</a> must be enabled for this parameter to function.</td>
      <td>yes</td>
      <td>JSON</td>
      <td>A JSON array of field names.</td>
    </tr>
    <tr>
      <td><code>drilldown</code></td>
      <td>This field can be used several times. Each use defines a pair of a field name and a value. The search matches only documents containing the value that was provided in the named field. It differs from using <code>&quot;fieldname:value&quot;</code>        in the <code>q</code> parameter only in that the values are not analyzed.
        <a href="#faceting">Faceting</a> must be enabled for this parameter to function.</td>
      <td>yes</td>
      <td>JSON</td>
      <td>A JSON array with two elements: the field name and the value.</td>
    </tr>
    <tr>
      <td><code>group_field</code></td>
      <td>Field by which to group search matches.</td>
      <td>yes</td>
      <td>String</td>
      <td>A string that contains the name of a string field. Fields containing other data such as numbers, objects, or arrays cannot be used.</td>
    </tr>
    <tr>
      <td><code>group_limit</code></td>
      <td>Maximum group count. This field can be used only if <code>group_field<code> is specified.</code></code>
      </td>
      <td>yes</td>
      <td>Numeric</td>
      <td></td>
    </tr>
    <tr>
      <td><code>group_sort</code></td>
      <td>This field defines the order of the groups in a search that uses <code>group_field</code>. The default sort order is relevance.</td>
      <td>yes</td>
      <td>JSON</td>
      <td>This field can have the same values as the sort field, so single fields and arrays of fields are supported.</td>
    </tr>
    <tr>
      <td><code>highlight_fields</code></td>
      <td>Specifies which fields to highlight. If specified, the result object contains a <code>highlights</code> field with an entry for each specified field.</td>
      <td>yes</td>
      <td>Array of strings</td>
      <td></td>
    </tr>
    <tr>
      <td><code>highlight_pre_tag</code></td>
      <td>A string that is inserted before the highlighted word in the highlights output.</td>
      <td>yes, defaults to <code>&lt;em&gt;</code></td>
      <td>String</td>
      <td></td>
    </tr>
    <tr>
      <td><code>highlight_post_tag</code></td>
      <td>A string that is inserted after the highlighted word in the highlights output.</td>
      <td>yes, defaults to <code>&lt;/em&gt;</code></td>
      <td>String</td>
      <td></td>
    </tr>
    <tr>
      <td><code>highlight_number</code></td>
      <td>Number of fragments that are returned in highlights. If the search term occurs less often than the number of fragments that are specified, longer fragments are returned.</td>
      <td>yes, defaults to 1</td>
      <td>Numeric</td>
      <td></td>
    </tr>
    <tr>
      <td><code>highlight_size</code></td>
      <td>Number of characters in each fragment for highlights.</td>
      <td>yes, defaults to 100 characters</td>
      <td>Numeric</td>
      <td></td>
    </tr>
    <tr>
      <td><code>include_docs</code></td>
      <td>Include the full content of the documents in the response.</td>
      <td>yes</td>
      <td>Boolean</td>
      <td></td>
    </tr>
    <tr>
      <td><code>include_fields</code></td>
      <td>A JSON array of field names to include in search results. Any fields that are included must be indexed with the <code>store:true</code> option.</td>
      <td>yes, the default is all fields</td>
      <td>Array of strings</td>
      <td></td>
    </tr>
    <tr>
      <td><code>limit</code></td>
      <td>Limit the number of the returned documents to the specified number. For a grouped search, this parameter limits the number of documents per group.</td>
      <td>yes</td>
      <td>Numeric</td>
      <td>The limit value can be any positive integer number up to and including 200.</td>
    </tr>
    <tr>
      <td><code>q</code></td>
      <td>Abbreviation for <code>query</code>. Runs a Lucene query.</td>
      <td>no</td>
      <td>string or number</td>
      <td></td>
    </tr>
    <tr>
      <td><code>query</code></td>
      <td>Runs a Lucene query.</td>
      <td>no</td>
      <td>string or number</td>
      <td></td>
    </tr>
    <tr>
      <td><code>ranges</code></td>
      <td>This field defines ranges for faceted, numeric search fields. The value is a JSON object where the fields names are faceted numeric search fields, and the values of the fields are JSON objects. The field names of the JSON objects are names for ranges.
        The values are strings that describe the range, for example <code>&quot;[0 TO 10]&quot;</code></td>
      <td>yes</td>
      <td>JSON</td>
      <td>The value must be an object with fields that have objects as their values. These objects must have strings with ranges as their field values.</td>
    </tr>
    <tr>
      <td><code>sort</code></td>
      <td>Specifies the sort order of the results. In a grouped search (when <code>group_field</code> is used), this parameter specifies the sort order within a group. The default sort order is relevance.</td>
      <td>yes</td>
      <td>JSON</td>
      <td>A JSON string of the form <code>&quot;fieldname&lt;type&gt;&quot;</code> or <code>-fieldname&lt;type&gt;</code> for descending order, where <code>fieldname</code> is the name of a string or number field, and <code>type</code> is either a number,
        a string, or a JSON array of strings. The <code>type</code> part is optional, and defaults to <code>number</code>. Some examples are <code>&quot;foo&quot;</code>,
        <code>&quot;-foo&quot;</code>,
        <code>&quot;bar&lt;string&gt;&quot;</code>,
        <code>&quot;-foo&lt;number&gt;&quot;</code> and <code>[&quot;-foo&lt;number&gt;&quot;,
&quot;bar&lt;string&gt;&quot;]</code>. String fields that are used for sorting must not be analyzed fields. Fields that are used for sorting must be indexed by the same indexer that is used for the search query.</td>
    </tr>
    <tr>
      <td><code>stale</code></td>
      <td>Do not wait for the index to finish building to return results.</td>
      <td>yes</td>
      <td>string</td>
      <td>ok</td>
    </tr>
  </table>
  <blockquote>
    <p> <strong>Note</strong>: Do not combine the <code>bookmark</code> and <code>stale</code> options. These options constrain the choice of shard replicas to use for the response. When used together, the options might cause problems when contact is attempted
      with replicas that are slow or not available.</p>
    <p> <strong>Note</strong>: Using <code>include_docs=true</code> might have <a href="using_views.html#include_docs_caveat">performance implications</a>.</p>
  </blockquote>
  <h3 id="relevance">Relevance</h3>
  <p>When more than one result might be returned, it is possible for them to be sorted. By default, the sorting order is determined by &#39;relevance&#39;.</p>
  <p>Relevance is measured according to
    <a href="https://lucene.apache.org/core/3_6_0/scoring.html" target="_blank">Apache Lucene Scoring <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>. As an example, if you search a simple database for the
    word &quot;<code>example</code>&quot;, two documents might contain the word. If one document mentions the word &quot;<code>example</code>&quot; 10 times, but the second document mentions it only twice, then the first document is considered to be more
    &#39;relevant&#39;.</p>
  <p>If you do not provide a <code>sort</code> parameter, relevance is used by default. The highest scoring matches are returned first.</p>
  <p>If you provide a <code>sort</code> parameter, then matches are returned in that order, ignoring relevance.</p>
  <p>If you want to use a <code>sort</code> parameter, and also include ordering by relevance in your search results, use the special fields <code>-&lt;score&gt;</code> or <code>&lt;score&gt;</code> within the <code>sort</code> parameter.</p>
  <h3 id="posting-search-queries">POSTing search queries</h3>
  <p>Instead of using the <code>GET</code> HTTP method, you can also use <code>POST</code>. The main advantage of <code>POST</code> queries is that they can have a request body, so you can specify the request as a JSON object. Each parameter in the previous
    table corresponds to a field in the JSON object in the request body.</p>
  <p><em>Example of using HTTP to <code>POST</code> a search request:</em></p>
  <pre class="codeblock"><code class="lang-http hljs"><span class="hljs-keyword">POST</span> <span class="hljs-string">/db/_design/ddoc/_search/searchname</span> HTTP/1.1
<span class="hljs-attribute">Content-Type</span>: application/json
<span class="hljs-attribute">Host</span>: account.cloudant.com
</code></pre>
  <p><em>Example of using the command line to <code>POST</code> a search request:</em></p>
  <pre class="codeblock"><code class="lang-sh hljs">curl <span class="hljs-string">'https://account.cloudant.com/db/_design/ddoc/_search/searchname'</span> -X POST -H <span class="hljs-string">'Content-Type: application/json'</span> <span class="hljs-_">-d</span> @search.json
</code></pre>
  <p><em>Example JSON document that contains a search request:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"q"</span>: <span class="hljs-string">"index:my query"</span>,
    <span class="hljs-attr">"sort"</span>: <span class="hljs-string">"foo"</span>,
    <span class="hljs-attr">"limit"</span>: <span class="hljs-number">3</span>
}
</code></pre>
  <h2 id="query-syntax">Query Syntax</h2>
  <p>The Cloudant search query syntax is based on the
    <a href="http://lucene.apache.org/core/4_3_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#Overview" target="_blank">Lucene syntax <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>.
    Search queries take the form of <code>name:value</code> unless the name is omitted, in which case they use the default field, as demonstrated in the following examples:</p>
  <blockquote>
    <p>Example search query expressions:</p>
  </blockquote>
  <pre class="codeblock"><code class="hljs">// Birds
class:bird

// Animals that begin with the letter &quot;l&quot;
l*

// Carnivorous birds
class:bird AND diet:carnivore

// Herbivores that start with letter &quot;l&quot;
l* AND diet:herbivore

// Medium-sized herbivores
min_length:[1 TO 3] AND diet:herbivore

// Herbivores that are 2m long or less
diet:herbivore AND min_length:[-Infinity TO 2]

// Mammals that are at least 1.5m long
class:mammal AND min_length:[1.5 TO Infinity]

// Find &quot;Meles meles&quot;
latin_name:&quot;Meles meles&quot;

// Mammals who are herbivore or carnivore
diet:(herbivore OR omnivore) AND class:mammal

// Return all results
*:*
</code></pre>
  <p>Queries over multiple fields can be logically combined, and groups and fields can be further grouped. The available logical operators are case-sensitive and are <code>AND</code>,
    <code>+</code>,
    <code>OR</code>,
    <code>NOT</code> and <code>-</code>. Range queries can run over strings or numbers.</p>
  <p>If you want a fuzzy search, you can run a query with <code>~</code> to find terms like the search term. For instance,
    <code>look~</code> finds the terms <code>book</code> and <code>took</code>.</p>
  <p>You can alter the importance of a search term by adding <code>^</code> and a positive number. This alteration makes matches containing the term more or less relevant, proportional to the power of the boost value. The default value is 1, which means
    no increase or decrease in the strength of the match. A decimal value of 0 - 1 reduces importance. making the match strength weaker. A value greater than one increases importance, making the match strength stronger.</p>
  <p>Wildcard searches are supported, for both single (<code>?</code>) and multiple (<code>*</code>) character searches. For example,
    <code>dat?</code> would match <code>date</code> and <code>data</code>, whereas <code>dat*</code> would match <code>date</code>,
    <code>data</code>,
    <code>database</code>, and <code>dates</code>. Wildcards must come after the search term.</p>
  <p>Use <code>*:*</code> to return all results.</p>
  <p>Result sets from searches are limited to 200 rows, and return 25 rows by default. The number of rows that are returned can be changed by using the <a href="#query-parameters"><code>limit</code> parameter</a>.</p>
  <p>If the search query does <em>not</em> specify the <code>&quot;group_field&quot;</code> argument, the response contains a bookmark. If this bookmark is later provided as a URL parameter, the response skips the rows that were seen already, making it quick
    and easy to get the next set of results.</p>
  <blockquote>
    <p> <strong>Note</strong>: The response never includes a bookmark if the <a href="#query-parameters"><code>&quot;group_field&quot;</code> parameter</a> is included in the search query.</p>
  </blockquote>
  <p>The following characters require escaping if you want to search on them:</p>
  <pre class="codeblock"><code class="hljs">+ - &amp;&amp; || ! ( ) { } [ ] ^ &quot; ~ * ? : \ /
</code></pre>
  <p>To escape one of these characters, use a preceding backslash character (<code>\</code>).</p>
  <p>The response to a search query contains an <code>order</code> field for each of the results. The <code>order</code> field is an array where the first element is the field or fields that are specified in the <a href="#query-parameters"><code>sort</code> parameter</a>.
    If no <a href="#query-parameters"><code>sort</code> parameter</a> is included in the query, then the <code>order</code> field contains the <a href="https://lucene.apache.org/core/3_6_0/scoring.html" target="_blank">Lucene relevance score <img src="../images/launch-glyph.svg" alt="External link icon" title="External link icon"></a>.
    If you use the &#39;sort by distance&#39; feature as described in <a href="#geographical-searches">Geographical Searches</a>, then the first element is the distance from a point. The distance is measured by using either kilometers or miles.</p>
  <blockquote>
    <p> <strong>Note</strong>: The second element in the order array can be ignored. It is used for troubleshooting purposes only.</p>
  </blockquote>
  <h2 id="faceting">Faceting</h2>
  <p>Cloudant Search also supports faceted searching, enabling discovery of aggregate information about matches quickly and easily. You can match all documents by using the special <code>?q=*:*</code> query syntax, and use the returned facets to refine your
    query. To indicate that a field must be indexed for faceted queries, set <code>{&quot;facet&quot;: true}</code> in its options.</p>
  <p><em>Example of search query, specifying that faceted search is enabled:</em></p>
  <pre class="codeblock"><code class="lang-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
    index(<span class="hljs-string">"type"</span>, doc.type, {<span class="hljs-string">"facet"</span>: <span class="hljs-literal">true</span>});
    index(<span class="hljs-string">"price"</span>, doc.price, {<span class="hljs-string">"facet"</span>: <span class="hljs-literal">true</span>});
}
</code></pre>
  <blockquote>
    <p> <strong>Note</strong>: To use facets, all the documents in the index must include all the fields that have faceting enabled. If your documents do not include all the fields, you receive a <code>bad_request</code> error with the following reason, &quot;dim
      <code>field_name</code> does not exist.&quot; If each document does not contain all the fields for facets, create separate indexes for each field. If you do not create separate indexes for each field, you must include only documents that contain
      all the fields. Verify that the fields exist in each document by using a single <code>if</code> statement.</p>
  </blockquote>
  <p><em>Example <code>if</code> statement to verify that the required fields exist in each document:</em></p>
  <pre class="codeblock"><code class="lang-javascript hljs"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> doc.town == <span class="hljs-string">"string"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> doc.name == <span class="hljs-string">"string"</span>) {
        index(<span class="hljs-string">"town"</span>, doc.town, {<span class="hljs-attr">facet</span>: <span class="hljs-literal">true</span>});
        index(<span class="hljs-string">"town"</span>, doc.town, {<span class="hljs-attr">facet</span>: <span class="hljs-literal">true</span>});
    }
</code></pre>
  <h3 id="counts">Counts</h3>
  <p>The <code>counts</code> facet syntax takes a list of fields, and returns the number of query results for each unique value of each named field.</p>
  <blockquote>
    <p> <strong>Note</strong>: The <code>count</code> operation works only if the indexed values are strings. The indexed values cannot be mixed types. For example, if 100 strings are indexed, and one number, then the index cannot be used for <code>count</code>      operations. You can check the type by using the &#39;<code>typeof</code>&#39; operator, and convert it by using the <code>parseInt</code>,
      <code>parseFloat</code>, or <code>.toString()</code> functions.</p>
  </blockquote>
  <p><em>Example of a query using the <code>counts</code> facet syntax:</em> </p>
  <pre class="codeblock"><code class="lang-http hljs">?q=*:*&amp;counts=["type"]
</code></pre>
  <p><em>Example response after using of the <code>counts</code> facet syntax:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"total_rows"</span>:<span class="hljs-number">100000</span>,
    <span class="hljs-attr">"bookmark"</span>:<span class="hljs-string">"g..."</span>,
    <span class="hljs-attr">"rows"</span>:[...],
    <span class="hljs-attr">"counts"</span>:{
        <span class="hljs-attr">"type"</span>:{
            <span class="hljs-attr">"sofa"</span>: <span class="hljs-number">10</span>,
            <span class="hljs-attr">"chair"</span>: <span class="hljs-number">100</span>,
            <span class="hljs-attr">"lamp"</span>: <span class="hljs-number">97</span>
        }
    }
}
</code></pre>
  <h3 id="-drilldown-"><code>drilldown</code></h3>
  <p>You can restrict results to documents with a dimension equal to the specified label. Restrict the results by adding <code>drilldown=[&quot;dimension&quot;,&quot;label&quot;]</code> to a search query. You can include multiple <code>drilldown</code> parameters
    to restrict results along multiple dimensions.</p>
  <p>Using a <code>drilldown</code> parameter is similar to using <code>key:value</code> in the <code>q</code> parameter, but the <code>drilldown</code> parameter returns values that the analyzer might skip.</p>
  <p>For example, if the analyzer did not index a stop word like <code>&quot;a&quot;</code>, using <code>drilldown</code> returns it when you specify <code>drilldown=[&quot;key&quot;,&quot;a&quot;]</code>.</p>
  <h3 id="ranges">Ranges</h3>
  <p>The <code>range</code> facet syntax reuses the standard Lucene syntax for ranges to return counts of results that fit into each specified category. Inclusive range queries are denoted by brackets (<code>[</code>, <code>]</code>). Exclusive range queries
    are denoted by curly brackets (<code>{</code>, <code>}</code>).</p>
  <blockquote>
    <p> <strong>Note</strong>: The <code>range</code> operation works only if the indexed values are numbers. The indexed values cannot be mixed types. For example, if 100 strings are indexed, and one number, then the index cannot be used for <code>range</code>      operations. You can check the type by using the &#39;<code>typeof</code>&#39; operator, and convert it by using the <code>parseInt</code>,
      <code>parseFloat</code>, or <code>.toString()</code> functions.</p>
  </blockquote>
  <p><em>Example of a request that uses faceted search for matching <code>ranges</code>:</em></p>
  <pre class="codeblock"><code class="lang-http hljs">?q=*:*&amp;ranges={"price":{"cheap":"[0 TO 100]","expensive":"{100 TO Infinity}"}}
</code></pre>
  <p><em>Example results after a <code>ranges</code> check on a faceted search:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"total_rows"</span>:<span class="hljs-number">100000</span>,
    <span class="hljs-attr">"bookmark"</span>:<span class="hljs-string">"g..."</span>,
    <span class="hljs-attr">"rows"</span>:[...],
    <span class="hljs-attr">"ranges"</span>: {
        <span class="hljs-attr">"price"</span>: {
            <span class="hljs-attr">"expensive"</span>: <span class="hljs-number">278682</span>,
            <span class="hljs-attr">"cheap"</span>: <span class="hljs-number">257023</span>
        }
    }
}
</code></pre>
  <h2 id="geographical-searches">Geographical searches</h2>
  <p>In addition to searching by the content of textual fields, you can also sort your results by their distance from a geographic coordinate.</p>
  <p>To sort your results in this way, you must index two numeric fields, representing the longitude and latitude.</p>
  <p>You can then query by using the special <code>&lt;distance...&gt;</code> sort field, which takes five parameters:</p>
  <ul>
    <li>Longitude field name: The name of your longitude field (&#39;<code>mylon</code>&#39; in the example).</li>
    <li>Latitude field name: The name of your latitude field (&#39;<code>mylat</code>&#39; in the example).</li>
    <li>Longitude of origin: The longitude of the place you want to sort by distance from.</li>
    <li>Latitude of origin: The latitude of the place you want to sort by distance from.</li>
    <li>Units: The units to use: &#39;<code>km</code>&#39; for kilometers or &#39;<code>mi</code>&#39; for miles. The distance is returned in the order field.</li>
  </ul>
  <p>You can combine sorting by distance with any other search query, such as range searches on the latitude and longitude, or queries that involve non-geographical information.</p>
  <p>That way, you can search in a bounding box, and narrow down the search with extra criteria.</p>
  <p><em>Example geographical data:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"name"</span>:<span class="hljs-string">"Aberdeen, Scotland"</span>,
    <span class="hljs-attr">"lat"</span>:<span class="hljs-number">57.15</span>,
    <span class="hljs-attr">"lon"</span>:<span class="hljs-number">-2.15</span>,
    <span class="hljs-attr">"type"</span>:<span class="hljs-string">"city"</span>
}
</code></pre>
  <p><em>Example of a design document that contains a search index for the geographic data:</em></p>
  <pre class="codeblock"><code class="lang-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
    <span class="hljs-keyword">if</span> (doc.type &amp;&amp; doc.type == <span class="hljs-string">'city'</span>) {
        index(<span class="hljs-string">'city'</span>, doc.name, {<span class="hljs-string">'store'</span>: <span class="hljs-literal">true</span>});
        index(<span class="hljs-string">'lat'</span>, doc.lat, {<span class="hljs-string">'store'</span>: <span class="hljs-literal">true</span>});
        index(<span class="hljs-string">'lon'</span>, doc.lon, {<span class="hljs-string">'store'</span>: <span class="hljs-literal">true</span>});
    }
}
</code></pre>
  <p><em>An example of using HTTP for a query that sorts cities in the northern hemisphere by their distance to New York:</em></p>
  <pre class="codeblock"><code class="lang-http hljs"><span class="hljs-keyword">GET</span> <span class="hljs-string">/examples/_design/cities-designdoc/_search/cities?q=lat:[0+TO+90]&amp;sort="&lt;distance,lon,lat,-74.0059,40.7127,km&gt;"</span> HTTP/1.1
<span class="hljs-attribute">Host</span>: $ACCOUNT.cloudant.com
</code></pre>
  <p><em>An example of using the command line for a query that sorts cities in the northern hemisphere by their distance to New York:</em></p>
  <pre class="codeblock"><code class="lang-sh hljs">curl <span class="hljs-string">'https://$ACCOUNT.cloudant.com/examples/_design/cities-designdoc/_search/cities?q=lat:[0+TO+90]&amp;sort="&lt;distance,lon,lat,-74.0059,40.7127,km&gt;"'</span>
</code></pre>
  <p><em>Example (abbreviated) response, containing a list of northern hemisphere cities sorted by distance to New York:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"total_rows"</span>: <span class="hljs-number">205</span>,
    <span class="hljs-attr">"bookmark"</span>: <span class="hljs-string">"g1A...XIU"</span>,
    <span class="hljs-attr">"rows"</span>: [
        {
            <span class="hljs-attr">"id"</span>: <span class="hljs-string">"city180"</span>,
            <span class="hljs-attr">"order"</span>: [
                <span class="hljs-number">8.530665755719783</span>,
                <span class="hljs-number">18</span>
            ],
            <span class="hljs-attr">"fields"</span>: {
                <span class="hljs-attr">"city"</span>: <span class="hljs-string">"New York, N.Y."</span>,
                <span class="hljs-attr">"lat"</span>: <span class="hljs-number">40.78333333333333</span>,
                <span class="hljs-attr">"lon"</span>: <span class="hljs-number">-73.96666666666667</span>
            }
        },
        {
            <span class="hljs-attr">"id"</span>: <span class="hljs-string">"city177"</span>,
            <span class="hljs-attr">"order"</span>: [
                <span class="hljs-number">13.756343205985946</span>,
                <span class="hljs-number">17</span>
            ],
            <span class="hljs-attr">"fields"</span>: {
                <span class="hljs-attr">"city"</span>: <span class="hljs-string">"Newark, N.J."</span>,
                <span class="hljs-attr">"lat"</span>: <span class="hljs-number">40.733333333333334</span>,
                <span class="hljs-attr">"lon"</span>: <span class="hljs-number">-74.16666666666667</span>
            }
        },
        {
            <span class="hljs-attr">"id"</span>: <span class="hljs-string">"city178"</span>,
            <span class="hljs-attr">"order"</span>: [
                <span class="hljs-number">113.53603438866077</span>,
                <span class="hljs-number">26</span>
            ],
            <span class="hljs-attr">"fields"</span>: {
                <span class="hljs-attr">"city"</span>: <span class="hljs-string">"New Haven, Conn."</span>,
                <span class="hljs-attr">"lat"</span>: <span class="hljs-number">41.31666666666667</span>,
                <span class="hljs-attr">"lon"</span>: <span class="hljs-number">-72.91666666666667</span>
            }
        }
    ]
}
</code></pre>
  <h2 id="highlighting-search-terms">Highlighting Search Terms</h2>
  <p>Sometimes it is useful to get the context in which a search term was mentioned so that you can display more emphasized results to a user.</p>
  <p>To get more emphasized results, add the <code>search_highlights</code> parameter to the search query. Specify the field names for which you would like excerpts, with the highlighted search term returned.</p>
  <p>By default, the search term is placed in <code>&lt;em&gt;</code> tags to highlight it, but the highlight can be overridden by using the <code>highlights_pre_tag</code> and <code>highlights_post_tag</code> parameters.</p>
  <p>The length of the fragments is 100 characters by default. A different length can be requested with the <code>highlights_size</code> parameter.</p>
  <p>The <code>highlights_number</code> parameter controls the number of fragments that are returned, and defaults to 1.</p>
  <p>In the response, a <code>highlights</code> field is added, with one subfield per field name.</p>
  <p>For each field, you receive an array of fragments with the search term highlighted.</p>
  <blockquote>
    <p> <strong>Note</strong>: For highlighting to work, store the field in the index by using the <code>store: true</code> option.</p>
  </blockquote>
  <p><em>Example of using HTTP to search with highlighting enabled:</em></p>
  <pre class="codeblock"><code class="lang-http hljs"><span class="hljs-keyword">GET</span> <span class="hljs-string">/movies/_design/searches/_search/movies?q=movie_name:Azazel&amp;highlight_fields=["movie_name"]&amp;highlight_pre_tag="&lt;b&gt;"&amp;highlight_post_tag="&lt;/b&gt;"&amp;highlights_size=30&amp;highlights_number=2</span> HTTP/1.1
<span class="hljs-attribute">HOST</span>: &lt;account&gt;.cloudant.com
<span class="hljs-attribute">Authorization</span>: ...
</code></pre>
  <p><em>Example of using the command line to search with highlighting enabled:</em></p>
  <pre class="codeblock"><code class="lang-sh hljs">curl <span class="hljs-string">"https://<span class="hljs-variable">$user</span>:<span class="hljs-variable">$password</span>@<span class="hljs-variable">$account</span>.cloudant.com/movies/_design/searches/_search/movies?q=movie_name:Azazel&amp;highlight_fields=\[\"movie_name\"\]&amp;highlight_pre_tag=\"&lt;b&gt;\"&amp;highlight_post_tag=\"&lt;/b&gt;\"&amp;highlights_size=30&amp;highlights_number=2</span>
</code></pre>
  <p><em>Example of highlighted search results:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"highlights"</span>: {
        <span class="hljs-attr">"movie_name"</span>: [
            <span class="hljs-string">" on the &lt;b&gt;Azazel&lt;/b&gt; Orient Express"</span>,
            <span class="hljs-string">" &lt;b&gt;Azazel&lt;/b&gt; manuals, you"</span>
        ]
    }
}
</code></pre>
  <h2 id="search-index-metadata">Search index metadata</h2>
  <p>To retrieve information about a search index, you send a <code>GET</code> request to the <code>_search_info</code> endpoint, as shown in the following example.
    <code>DDOC</code> refers to the design document that contains the index, and <code>INDEX</code> is the name of the index.</p>
  <p><em>Example of using HTTP to request search index metadata:</em></p>
  <pre class="codeblock"><code class="lang-http hljs"><span class="hljs-keyword">GET</span> <span class="hljs-string">/&lt;DATABASE&gt;/_design/&lt;DDOC&gt;/_search_info/&lt;INDEX&gt;</span> HTTP/1.1
</code></pre>
  <p><em>Example of using the command line to request search index metadata:</em></p>
  <pre class="codeblock"><code class="lang-sh hljs">curl <span class="hljs-string">"https://<span class="hljs-variable">$ACCOUNT</span>.cloudant.com/<span class="hljs-variable">$DATABASE</span>/_design/<span class="hljs-variable">$DDOC</span>/_search_info/<span class="hljs-variable">$INDEX</span>"</span> \
     -X GET -u <span class="hljs-string">"<span class="hljs-variable">$USERNAME</span>:<span class="hljs-variable">$PASSWORD</span>"</span>
</code></pre>
  <p>The response contains information about your index, such as the number of documents in the index and the size of the index on disk.</p>
  <p><em>Example response after requesting search index metadata:</em></p>
  <pre class="codeblock"><code class="lang-json hljs">{
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"_design/DDOC/INDEX"</span>,
    <span class="hljs-attr">"search_index"</span>: {
        <span class="hljs-attr">"pending_seq"</span>: <span class="hljs-number">7125496</span>,
        <span class="hljs-attr">"doc_del_count"</span>: <span class="hljs-number">129180</span>,
        <span class="hljs-attr">"doc_count"</span>: <span class="hljs-number">1066173</span>,
        <span class="hljs-attr">"disk_size"</span>: <span class="hljs-number">728305827</span>,
        <span class="hljs-attr">"committed_seq"</span>: <span class="hljs-number">7125496</span>
    }
}
</code></pre>
  <footer>
    <div>
      <p>Copyright &copy; 2015, 2017. All Rights Reserved.</p>
    </div>
  </footer>
</body>
</html>